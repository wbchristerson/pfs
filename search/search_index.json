{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello! This website showcases some projects that I have created in various programming languages. In May 2017, I graduated with honors from Carnegie Mellon University with a Bachelor of Science in Mathematics. I am a native New Yorker and after completing my studies I returned to the city. For the past year and a half, I have been working as a software engineer at the educational technology start-up 101 Edu , dealing mostly with front-end development on web and mobile platforms but also with some exposure to server-side architecture. I am interested in discrete math, computer science, and applications of statistics and probability in finance. Lately, I have also been trying to learn more about machine learning with data analysis technologies like Numpy, Pandas, and TensorFlow. Here is my GitHub account and here is my LinkedIn page. Projects NN Flower Classifier A command line application to train and run a neural network to identify flower species based on previous image data. Python \u26ac Jupyter Notebook \u26ac PyTorch Maximum Matchings An interactive application to demonstrate a classic algorithm for determining maximum matchings in bipartite graphs. Python Neighborhood Map A map application providing information about local restaurants, stores, and other venues in Manhattan Beach, California. React \u26ac CSS \u26ac Google Maps API Mobile Flashcards An Android mobile application for creating flashcard decks and then quizzing yourself on your decks. React Native Readables A basic forum and posting application allowing comments, voting, editing, and topic differentiation. React \u26ac Redux \u26ac CSS My Reads A book-tracking application listing the books currently in a user's library together with a large collection of available books to search for. React Mathematical Database A small-scale interactive database storing solutions to challenging mathematical puzzles and problems drawn from various sources. Python Frogger A re-creation of the classic arcade game Frogger. JavaScript \u26ac HTML \u26ac CSS Matching Game A memory challenge for users to match hidden cards in a timed setting. JavaScript (jQuery) \u26ac HTML \u26ac CSS Pixel Art Maker An application to make colorful pixel images of varying grid sizes using an extensive color palette. JavaScript (jQuery) \u26ac HTML \u26ac CSS Attribution This website was created using MkDocs and Material for MkDocs Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#hello","text":"This website showcases some projects that I have created in various programming languages. In May 2017, I graduated with honors from Carnegie Mellon University with a Bachelor of Science in Mathematics. I am a native New Yorker and after completing my studies I returned to the city. For the past year and a half, I have been working as a software engineer at the educational technology start-up 101 Edu , dealing mostly with front-end development on web and mobile platforms but also with some exposure to server-side architecture. I am interested in discrete math, computer science, and applications of statistics and probability in finance. Lately, I have also been trying to learn more about machine learning with data analysis technologies like Numpy, Pandas, and TensorFlow. Here is my GitHub account and here is my LinkedIn page.","title":"Hello!"},{"location":"#projects","text":"","title":"Projects"},{"location":"#attribution","text":"This website was created using MkDocs and Material for MkDocs","title":"Attribution"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"FlowerClassifier/","text":"Neural Network Flower Classifier GitHub repository: https://github.com/wbchristerson/transfer-learning-classifier Overview This project is split into two main parts: An image classifier for classifying various species of flowers based on images, using a neural network created in a Jupyter Notebook using PyTorch A command line application written in Python to use the image classifier in various instances Image Classifier Typically, convolutional neural networks (CNN) are used for image classification problems. Among other reasons, they use filters to determine distinctive shapes in images which are especially helpful in classification. In Image Classifier Project.ipynb , I used a pre-trained convolutional neural network (specifically VGG11) to obtain the convolutional filters normally used in CNNs to identify specific shapes in images. I then used a relatively smaller neural network as the classifier meant to determine the identity of each of a set of flowers based on previous images of different flower species. During the training process, the extensive set of weights provided by VGG11 were frozen while the weights of the neural network classifier were updated and tuned so as to maintain a manageable training time. To mitigate overfitting of the neural network classifier to the training data set, I used dropout so that during various feedforward/backward passes of the training process, some nodes were frozen (not updated) with a certain probability at each pass. For internal layers, I used ReLU activation functions and for the final layer I used a log softmax function (as ReLU is not suitable for providing final classification probabilities). After training the network and testing on a validation set and testing set, I saved the network as a checkpoint for later use without the need to re-train the model. I was able to achieve > 75% accuracy on the testing set using this architecture. Python Command Line Application Using the Python application, a user may classify flower species by using the saved neural network or by setting various options and then training their own model. Available options include: * the number of best matching categories to return (e.g. for 3, the categories with the top 3 probabilities are shown) * whether to run with GPU enabled (this will significantly speed up the training process) * the number of training epochs * the number of hidden units in the classifier * the learning rate (i.e. step size for backpropagation) * the type of architecture to be used for the pre-trained convolutional layers Notes To run the Jupyter Notebook, you must have Python installed. You will also need to be able to access the Jupyter notebook; I recommend installing the Anaconda distribution, or for a smaller download, Miniconda . Both come with Python during installation. To run the notebook, use the command jupyter-notebook (depending on your version of Python and Jupyter Notebook , you may require some variation of this terminal command). This will open a browser window and the Jupyter Notebook dashboard, from which you can navigate to Image Classifier Project.ipynb . This project was cloned from the starter code provided by Udacity's AI Programming with Python Nanodegree program.","title":"Neural Network Flower Classifier"},{"location":"FlowerClassifier/#neural-network-flower-classifier","text":"GitHub repository: https://github.com/wbchristerson/transfer-learning-classifier","title":"Neural Network Flower Classifier"},{"location":"FlowerClassifier/#overview","text":"This project is split into two main parts: An image classifier for classifying various species of flowers based on images, using a neural network created in a Jupyter Notebook using PyTorch A command line application written in Python to use the image classifier in various instances","title":"Overview"},{"location":"FlowerClassifier/#image-classifier","text":"Typically, convolutional neural networks (CNN) are used for image classification problems. Among other reasons, they use filters to determine distinctive shapes in images which are especially helpful in classification. In Image Classifier Project.ipynb , I used a pre-trained convolutional neural network (specifically VGG11) to obtain the convolutional filters normally used in CNNs to identify specific shapes in images. I then used a relatively smaller neural network as the classifier meant to determine the identity of each of a set of flowers based on previous images of different flower species. During the training process, the extensive set of weights provided by VGG11 were frozen while the weights of the neural network classifier were updated and tuned so as to maintain a manageable training time. To mitigate overfitting of the neural network classifier to the training data set, I used dropout so that during various feedforward/backward passes of the training process, some nodes were frozen (not updated) with a certain probability at each pass. For internal layers, I used ReLU activation functions and for the final layer I used a log softmax function (as ReLU is not suitable for providing final classification probabilities). After training the network and testing on a validation set and testing set, I saved the network as a checkpoint for later use without the need to re-train the model. I was able to achieve > 75% accuracy on the testing set using this architecture.","title":"Image Classifier"},{"location":"FlowerClassifier/#python-command-line-application","text":"Using the Python application, a user may classify flower species by using the saved neural network or by setting various options and then training their own model. Available options include: * the number of best matching categories to return (e.g. for 3, the categories with the top 3 probabilities are shown) * whether to run with GPU enabled (this will significantly speed up the training process) * the number of training epochs * the number of hidden units in the classifier * the learning rate (i.e. step size for backpropagation) * the type of architecture to be used for the pre-trained convolutional layers","title":"Python Command Line Application"},{"location":"FlowerClassifier/#notes","text":"To run the Jupyter Notebook, you must have Python installed. You will also need to be able to access the Jupyter notebook; I recommend installing the Anaconda distribution, or for a smaller download, Miniconda . Both come with Python during installation. To run the notebook, use the command jupyter-notebook (depending on your version of Python and Jupyter Notebook , you may require some variation of this terminal command). This will open a browser window and the Jupyter Notebook dashboard, from which you can navigate to Image Classifier Project.ipynb . This project was cloned from the starter code provided by Udacity's AI Programming with Python Nanodegree program.","title":"Notes"},{"location":"Frogger/","text":"Frogger GitHub repository: https://github.com/wbchristerson/arcade-game This project re-creates the arcade game Frogger using JavaScript and a basic HTML/CSS skeleton. Try the game here. Note: This project is based on a skeleton structure from Udacity. For more information, see the initial commit on the appropriate GitHub page given above. Structure The game has 15 levels which the player must complete while avoiding enemy bugs. You traverse the board using the arrow keys. If you come in contact with a bug, you lose a life and return to the default position on screen. You can also collect gems (of varying point values) and stars (which give extra lives). If you lose all your lives, the game is over. If you complete all 15 levels with at least one life left, you win. When the game ends, you may play again or return to the introductory page. Design The game begins with an introductory page explaining how to play. It also lists the player's possible avatars, along with which keys to press to switch avatars. Begin by pressing the \"space\" key. The game page includes a background of grass, brick, and water. Your score, remaining lives, and level appear at the bottom. You have to cross the board while avoiding enemy bugs. Gems and stars appear occasionally, and you get points for every gem you collect: 3 for blue gems, 6 for green gems, and 9 for orange gems. The end page resembles the introductory page and congratulates you on completing the game. The game becomes increasingly difficult. The chance of each of three independent rocks appearing on screen increases up to level 5, after which time they will all always appear (though sometimes overlapping each other). One strategy to avoid losing lives is to wait for the right half of the screen to become clear and cross from that half (since enemy bugs always cross the screen from left to right). To further increase difficulty beyond level 5, a fourth rock will always appear somewhere in the rightmost column. Running The Application Run the application in your browser by clicking here . To download, clone the repository using this terminal command: git clone https://github.com/wbchristerson/arcade-game.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder arcade-game-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\" then extract. Open your browser and use Ctrl + O (for Windows machines) to open the file selector on your device. Go to arcade-game-master , enter arcade-game-master again, then select index.html . The game screen will appear.","title":"Frogger"},{"location":"Frogger/#frogger","text":"GitHub repository: https://github.com/wbchristerson/arcade-game This project re-creates the arcade game Frogger using JavaScript and a basic HTML/CSS skeleton. Try the game here. Note: This project is based on a skeleton structure from Udacity. For more information, see the initial commit on the appropriate GitHub page given above. Structure The game has 15 levels which the player must complete while avoiding enemy bugs. You traverse the board using the arrow keys. If you come in contact with a bug, you lose a life and return to the default position on screen. You can also collect gems (of varying point values) and stars (which give extra lives). If you lose all your lives, the game is over. If you complete all 15 levels with at least one life left, you win. When the game ends, you may play again or return to the introductory page. Design The game begins with an introductory page explaining how to play. It also lists the player's possible avatars, along with which keys to press to switch avatars. Begin by pressing the \"space\" key. The game page includes a background of grass, brick, and water. Your score, remaining lives, and level appear at the bottom. You have to cross the board while avoiding enemy bugs. Gems and stars appear occasionally, and you get points for every gem you collect: 3 for blue gems, 6 for green gems, and 9 for orange gems. The end page resembles the introductory page and congratulates you on completing the game. The game becomes increasingly difficult. The chance of each of three independent rocks appearing on screen increases up to level 5, after which time they will all always appear (though sometimes overlapping each other). One strategy to avoid losing lives is to wait for the right half of the screen to become clear and cross from that half (since enemy bugs always cross the screen from left to right). To further increase difficulty beyond level 5, a fourth rock will always appear somewhere in the rightmost column. Running The Application Run the application in your browser by clicking here . To download, clone the repository using this terminal command: git clone https://github.com/wbchristerson/arcade-game.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder arcade-game-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\" then extract. Open your browser and use Ctrl + O (for Windows machines) to open the file selector on your device. Go to arcade-game-master , enter arcade-game-master again, then select index.html . The game screen will appear.","title":"Frogger"},{"location":"MatchingGame/","text":"Matching Game GitHub repository: https://github.com/wbchristerson/memory-game Using HTML, CSS, and JavaScript, this two-page application challenges the player to find all matching pairs of cards in the fewest moves. To try the game, click here . Note: This project is based on a skeleton structure from Udacity. For more information, see the initial commit on the appropriate GitHub page given above. Structure You must find the 8 matching images from cards that are turned over. When you click a card, it flips, turns blue, and the hidden image appears. When you make a match, the cards change color and the images remain visible. If you do not make a match, the cards flip back over to their original display. Once you match all cards, the game is over and the screen congratulates you, listing various statistics about your game. To play again, click the \"play again\" button. Design The main screen includes a timer, a move counter, a reset button, and a star rating. Below is an example of the interface: Finishing with at most 15 moves yields a 3-star rating, finishing with more than 16 moves but at most 25 yields a 2-star rating, and finishing with more than 25 moves yields a 1-star rating. Here is an example end page: Running The Application Run the application in your browser by clicking here . To download, clone the repository using this terminal command: git clone https://github.com/wbchristerson/memory-game.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder memory-game-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\" then extract. Open your browser and use Ctrl + O (for Windows machines) to open the file selector on your device. Go to memory-game-master , enter memory-game-master again, then select index.html . The game screen will appear.","title":"Matching Game"},{"location":"MatchingGame/#matching-game","text":"GitHub repository: https://github.com/wbchristerson/memory-game Using HTML, CSS, and JavaScript, this two-page application challenges the player to find all matching pairs of cards in the fewest moves. To try the game, click here . Note: This project is based on a skeleton structure from Udacity. For more information, see the initial commit on the appropriate GitHub page given above. Structure You must find the 8 matching images from cards that are turned over. When you click a card, it flips, turns blue, and the hidden image appears. When you make a match, the cards change color and the images remain visible. If you do not make a match, the cards flip back over to their original display. Once you match all cards, the game is over and the screen congratulates you, listing various statistics about your game. To play again, click the \"play again\" button. Design The main screen includes a timer, a move counter, a reset button, and a star rating. Below is an example of the interface: Finishing with at most 15 moves yields a 3-star rating, finishing with more than 16 moves but at most 25 yields a 2-star rating, and finishing with more than 25 moves yields a 1-star rating. Here is an example end page: Running The Application Run the application in your browser by clicking here . To download, clone the repository using this terminal command: git clone https://github.com/wbchristerson/memory-game.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder memory-game-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\" then extract. Open your browser and use Ctrl + O (for Windows machines) to open the file selector on your device. Go to memory-game-master , enter memory-game-master again, then select index.html . The game screen will appear.","title":"Matching Game"},{"location":"MathematicalDatabase/","text":"Mathematical Database GitHub repository: https://github.com/wbchristerson/database This project is a small-scale database that uses Python and the graphical user interface package, Tkinter. The database stores solutions to challenging mathematical puzzles and problems drawn from various sources, including mathematical olympiads; however, it can easily be adapted to store other information. Structure The database opens with a menu page and the following buttons: \"Look Up An Entry\"; \"Browse Entries\"; \"Add An Entry\"; and \"Edit An Entry\". \"Look Up An Entry\" searches for various pieces of information or by an assigned ID. An expanded view for matching data entries is also available. \"Browse Entries\" lists all data entries in both a short form and an expanded view, similar to \"Look Up An Entry\". \"Write Page\" adds data entries. Since the main purpose of the database is to store mathematical puzzles and problems, accepted data include: topic key words (tags) source date of completion level of difficulty problem/puzzle statement (with or without LaTeX formatting) solution (with or without LaTeX formatting) additional notes \"Edit An Entry\" alters information about existing data entries. IDs cannot be changed. The project was inspired by this post by v_Enhance on the website Art of Problem Solving. Design The application begins with the menu shown above. All other page frames have return buttons back to this page. Clicking \"Look Up An Entry\" brings you to the following frame in the first image below. As mentioned above, you can make queries based on ID in the database or one of the \"Add Entry\" attributes described above. When the corresponding check box is clicked, an entry widget appears to input data. If no items match the search conditions, then a message to this effect appears in the following text box. Otherwise, a series of search results appears, as seen in the second image below. An \"expanded view\" check button can be used to toggle between abridged and complete forms of data entries. Warnings will be given for invalid or out-of-range IDs or dates. Note that the \"Mentioned Words\" and \"Source\" fields will select entries which match any single searched word (even among many). Clicking \"Browse Entries\" brings you to the following frame in the first image below. Clicking \"Browse\" will provide a list of all entries in the database as seen in the second image below. Similar to \"Look Up An Entry\", clicking the \"Expanded View\" button will provide more information about items. Clicking \"Add An Entry\" brings you to the following frame in the first image below. The fields for a new data entry match those on the \"Look Up An Entry\" page, as seen in the second image below. The entry can be cancelled or saved, after which you return to the menu. Warnings are provided for invalid date entries. The collection of all data entries is kept in a JSON file as a list of \"DataEntry\" objects (which is stored in the form of a list of Python dictionaries for serialization). Clicking \"Edit An Entry\" brings you to the following frame in the first image below. Input an ID and click \"Edit\" to update an entry. The fields will be populated with the corresponding data, as shown below in the second image. If the ID is invalid or out of range then a warning appears. Similarly, warnings appear for updating a date to an invalid choice. When finished updating, click the save button. If you do not wish to keep the changes, cancel. In both cases, you will return to the menu page. Running The Application Python must be installed on your computer to run the application. If you do not have it installed, you can download it for free. For details, see this page . For reference, this project was created using Python version 3.1. If you are running an operating system other than Windows, then you may have to download and install additional software to accommodate the Tkinter toolkit. To learn more or to trouble shoot, see these pages: https://www.python.org/download/mac/tcltk/ https://wiki.python.org/moin/TkInter https://stackoverflow.com/questions/36760839/why-my-python-installed-via-home-brew-not-include-tkinter To download the project, you can clone the repository using this terminal command: git clone https://github.com/wbchristerson/database.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder database-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\". Go to database-master , enter database-master again, then double click database.py . The menu will appear. Note: The project comes with sample database entries to illustrate how the application works. If you wish to delete these entries and begin with a completely blank database, double click the file delete_database.py . A window will open, prompting you to confirm that you wish to delete all existing entries. To continue, type 'y'. To cancel, type 'n'. For a more aesthetically pleasing presentation of the original problems in the database, see sample_problems.pdf .","title":"Mathematical Database"},{"location":"MathematicalDatabase/#mathematical-database","text":"GitHub repository: https://github.com/wbchristerson/database This project is a small-scale database that uses Python and the graphical user interface package, Tkinter. The database stores solutions to challenging mathematical puzzles and problems drawn from various sources, including mathematical olympiads; however, it can easily be adapted to store other information. Structure The database opens with a menu page and the following buttons: \"Look Up An Entry\"; \"Browse Entries\"; \"Add An Entry\"; and \"Edit An Entry\". \"Look Up An Entry\" searches for various pieces of information or by an assigned ID. An expanded view for matching data entries is also available. \"Browse Entries\" lists all data entries in both a short form and an expanded view, similar to \"Look Up An Entry\". \"Write Page\" adds data entries. Since the main purpose of the database is to store mathematical puzzles and problems, accepted data include: topic key words (tags) source date of completion level of difficulty problem/puzzle statement (with or without LaTeX formatting) solution (with or without LaTeX formatting) additional notes \"Edit An Entry\" alters information about existing data entries. IDs cannot be changed. The project was inspired by this post by v_Enhance on the website Art of Problem Solving. Design The application begins with the menu shown above. All other page frames have return buttons back to this page. Clicking \"Look Up An Entry\" brings you to the following frame in the first image below. As mentioned above, you can make queries based on ID in the database or one of the \"Add Entry\" attributes described above. When the corresponding check box is clicked, an entry widget appears to input data. If no items match the search conditions, then a message to this effect appears in the following text box. Otherwise, a series of search results appears, as seen in the second image below. An \"expanded view\" check button can be used to toggle between abridged and complete forms of data entries. Warnings will be given for invalid or out-of-range IDs or dates. Note that the \"Mentioned Words\" and \"Source\" fields will select entries which match any single searched word (even among many). Clicking \"Browse Entries\" brings you to the following frame in the first image below. Clicking \"Browse\" will provide a list of all entries in the database as seen in the second image below. Similar to \"Look Up An Entry\", clicking the \"Expanded View\" button will provide more information about items. Clicking \"Add An Entry\" brings you to the following frame in the first image below. The fields for a new data entry match those on the \"Look Up An Entry\" page, as seen in the second image below. The entry can be cancelled or saved, after which you return to the menu. Warnings are provided for invalid date entries. The collection of all data entries is kept in a JSON file as a list of \"DataEntry\" objects (which is stored in the form of a list of Python dictionaries for serialization). Clicking \"Edit An Entry\" brings you to the following frame in the first image below. Input an ID and click \"Edit\" to update an entry. The fields will be populated with the corresponding data, as shown below in the second image. If the ID is invalid or out of range then a warning appears. Similarly, warnings appear for updating a date to an invalid choice. When finished updating, click the save button. If you do not wish to keep the changes, cancel. In both cases, you will return to the menu page. Running The Application Python must be installed on your computer to run the application. If you do not have it installed, you can download it for free. For details, see this page . For reference, this project was created using Python version 3.1. If you are running an operating system other than Windows, then you may have to download and install additional software to accommodate the Tkinter toolkit. To learn more or to trouble shoot, see these pages: https://www.python.org/download/mac/tcltk/ https://wiki.python.org/moin/TkInter https://stackoverflow.com/questions/36760839/why-my-python-installed-via-home-brew-not-include-tkinter To download the project, you can clone the repository using this terminal command: git clone https://github.com/wbchristerson/database.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder database-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\". Go to database-master , enter database-master again, then double click database.py . The menu will appear. Note: The project comes with sample database entries to illustrate how the application works. If you wish to delete these entries and begin with a completely blank database, double click the file delete_database.py . A window will open, prompting you to confirm that you wish to delete all existing entries. To continue, type 'y'. To cancel, type 'n'. For a more aesthetically pleasing presentation of the original problems in the database, see sample_problems.pdf .","title":"Mathematical Database"},{"location":"MaximumMatchings/","text":"Maximum Matchings GitHub repository: https://github.com/wbchristerson/perfect-matchings This application demonstrates an algorithm for finding maximum matchings in bipartite graphs. The general procedure used begins with finding any maximal matching greedily, then expanding the matching using augmenting paths via almost augmenting paths. For a detailed explanation of the concepts involved, see Maximum_Matchings.pdf . The user can choose the bipartite graph in various ways or add edges randomly. There is then a series of selection options for demonstrating the algorithm. This project was created using Python along with the pygame and livewires packages. Structure The user may navigate through the various pages to choose the bipartite graph examined. There are options to choose the sizes of the branches as well as which edges appear. Alternatively, edges can be chosen for the user randomly. There are then options for attempting to find a maximum matching manually, as well as for immediately displaying a maximum matching. In addition, the user may watch the application of the algorithm continuously or with steps. Design To navigate throughout the pages of the program, there are buttons which can be hovered over. To push the buttons you must push the space bar while hovered over, rather than clicking. The application begins with a page for selecting the left branch size. This is followed by a similar page for selecting the right branch size. The user may then elect to choose edges manually or to allow the program to randomly select edges, adding any individual edge using a pseudo-random number generator with probability 40%. Below is a view for making edge selections manually. The user is then taken to a page for selecting the type of operation to apply. Upon selecting the manual matching option, the user is allowed to select edges of the graph to try to find a maximum matching. Congratulations are given upon succeeding. After selecting the automatic matching option, a maximum matching is immediately displayed. If the user selects the option to watch the algorithm, the steps of the algorithm will be displayed with changes occurring every few seconds (with a pause button available). The first image below is a still of the initial greedy matching generation and the second image below is a still of the identification of an augmenting path to increase the size of the matching. The fourth option also displays the steps of the algorithm but with buttons to follow the steps. Running The Application You will need to have Python installed, as well as the pygame and livewires libraries. The version of livewires used for this project was taken from this download (which also contains downloads for Python and pygame), under \"Book related software\". To download Python only, visit this page . To download, clone the repository using this terminal command: git clone https://github.com/wbchristerson/perfect-matchings.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder perfect-matchings-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\" then extract. From within the directory generated through extraction (named perfect-matchings-master , unless you changed the file name), double click on the batch file main.bat . A window will open on screen, beginning the program. If you encounter errors involving pygame or livewires , make sure that those packages are installed in lib/site-packages from the level of the directory containing this project.","title":"Maximum Matchings"},{"location":"MaximumMatchings/#maximum-matchings","text":"GitHub repository: https://github.com/wbchristerson/perfect-matchings This application demonstrates an algorithm for finding maximum matchings in bipartite graphs. The general procedure used begins with finding any maximal matching greedily, then expanding the matching using augmenting paths via almost augmenting paths. For a detailed explanation of the concepts involved, see Maximum_Matchings.pdf . The user can choose the bipartite graph in various ways or add edges randomly. There is then a series of selection options for demonstrating the algorithm. This project was created using Python along with the pygame and livewires packages. Structure The user may navigate through the various pages to choose the bipartite graph examined. There are options to choose the sizes of the branches as well as which edges appear. Alternatively, edges can be chosen for the user randomly. There are then options for attempting to find a maximum matching manually, as well as for immediately displaying a maximum matching. In addition, the user may watch the application of the algorithm continuously or with steps. Design To navigate throughout the pages of the program, there are buttons which can be hovered over. To push the buttons you must push the space bar while hovered over, rather than clicking. The application begins with a page for selecting the left branch size. This is followed by a similar page for selecting the right branch size. The user may then elect to choose edges manually or to allow the program to randomly select edges, adding any individual edge using a pseudo-random number generator with probability 40%. Below is a view for making edge selections manually. The user is then taken to a page for selecting the type of operation to apply. Upon selecting the manual matching option, the user is allowed to select edges of the graph to try to find a maximum matching. Congratulations are given upon succeeding. After selecting the automatic matching option, a maximum matching is immediately displayed. If the user selects the option to watch the algorithm, the steps of the algorithm will be displayed with changes occurring every few seconds (with a pause button available). The first image below is a still of the initial greedy matching generation and the second image below is a still of the identification of an augmenting path to increase the size of the matching. The fourth option also displays the steps of the algorithm but with buttons to follow the steps. Running The Application You will need to have Python installed, as well as the pygame and livewires libraries. The version of livewires used for this project was taken from this download (which also contains downloads for Python and pygame), under \"Book related software\". To download Python only, visit this page . To download, clone the repository using this terminal command: git clone https://github.com/wbchristerson/perfect-matchings.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder perfect-matchings-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\" then extract. From within the directory generated through extraction (named perfect-matchings-master , unless you changed the file name), double click on the batch file main.bat . A window will open on screen, beginning the program. If you encounter errors involving pygame or livewires , make sure that those packages are installed in lib/site-packages from the level of the directory containing this project.","title":"Maximum Matchings"},{"location":"MobileFlashcards/","text":"Mobile Flashcards GitHub repository: https://github.com/wbchristerson/MobileFlashcards This project is a flashcard application for Android mobile devices in which users may create collections of flashcards and quiz themselves on the decks that they compile. I created the application using react-native along with redux . (This project was bootstrapped with Create React Native App .) Structure The main section includes a tab navigator for flashcard decks that have already been created as well as a tab for creating new decks. Clicking on a deck tile takes the user to the individual page for the topic, where additional cards for the deck can be created and added. From the individual deck page, users may also take quizzes in which they mark their responses based on the answers shown. Afterwards, a score is given. Design As said above, the application begins with a tab navigator composed of two screens. The first is a list view of all currently available flashcard decks. As a starting point, two decks are already provided: \"Spanish\" (9 cards) and \"Architecture\" (2 cards) . You may quiz yourself with these or add new decks. The second screen in the tab navigator is a form to add an additional deck (\"new deck\"). Submitting the form will take the user to the new page for that deck. Individual deck pages can be reached by clicking on a deck from the list view. This lists the name of the deck, the number of cards, and buttons for adding a card to the deck as well as for quizzing one's self. The \"new card\" form is similar to the \"new deck\" form. The quiz page displays the deck questions in order with an available button to check the answer and then grade one's self. Clicking the answer field will reveal the answer to the given question. When the user finishes looking through the deck, his/her score is shown. To maintain data for this application, I used the AsyncStorage key-value storage system heavily. Running The Application To download, you can clone the repository using this terminal command: git clone https://github.com/wbchristerson/MobileFlashcards.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page. Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder MobileFlashcards-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\" then extract. In all cases, having downloaded the files: To install all dependencies from the command line, run the following command in the terminal within the project folder: npm install In another terminal window, run the following command to start the project: npm start The terminal will then provide you with several options. If you have the application Expo on your device, then you can scan the accompanying QR code that appears. This will give you the option to run the application on mobile (note: the scan is most easily executed on terminals with a black background and a gray or white foreground). For complete details about running react-native applications such as this one on mobile devices, see here .","title":"Mobile Flashcards"},{"location":"MobileFlashcards/#mobile-flashcards","text":"GitHub repository: https://github.com/wbchristerson/MobileFlashcards This project is a flashcard application for Android mobile devices in which users may create collections of flashcards and quiz themselves on the decks that they compile. I created the application using react-native along with redux . (This project was bootstrapped with Create React Native App .) Structure The main section includes a tab navigator for flashcard decks that have already been created as well as a tab for creating new decks. Clicking on a deck tile takes the user to the individual page for the topic, where additional cards for the deck can be created and added. From the individual deck page, users may also take quizzes in which they mark their responses based on the answers shown. Afterwards, a score is given. Design As said above, the application begins with a tab navigator composed of two screens. The first is a list view of all currently available flashcard decks. As a starting point, two decks are already provided: \"Spanish\" (9 cards) and \"Architecture\" (2 cards) . You may quiz yourself with these or add new decks. The second screen in the tab navigator is a form to add an additional deck (\"new deck\"). Submitting the form will take the user to the new page for that deck. Individual deck pages can be reached by clicking on a deck from the list view. This lists the name of the deck, the number of cards, and buttons for adding a card to the deck as well as for quizzing one's self. The \"new card\" form is similar to the \"new deck\" form. The quiz page displays the deck questions in order with an available button to check the answer and then grade one's self. Clicking the answer field will reveal the answer to the given question. When the user finishes looking through the deck, his/her score is shown. To maintain data for this application, I used the AsyncStorage key-value storage system heavily. Running The Application To download, you can clone the repository using this terminal command: git clone https://github.com/wbchristerson/MobileFlashcards.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page. Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder MobileFlashcards-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\" then extract. In all cases, having downloaded the files: To install all dependencies from the command line, run the following command in the terminal within the project folder: npm install In another terminal window, run the following command to start the project: npm start The terminal will then provide you with several options. If you have the application Expo on your device, then you can scan the accompanying QR code that appears. This will give you the option to run the application on mobile (note: the scan is most easily executed on terminals with a black background and a gray or white foreground). For complete details about running react-native applications such as this one on mobile devices, see here .","title":"Mobile Flashcards"},{"location":"MyReads/","text":"My Reads GitHub repository: https://github.com/wbchristerson/reactnd-project-myreads-starter This application keeps track of a user's book selections from a static database on a server. The user may query certain topics and then select books from the search results to appear on one of three shelves on the main page: \"Currently Reading\", \"Want To Read\", and \"Read\". The project was completed using React, with a basic template and server provided by Udacity. Structure The main page displays the set of books selected. Such books are shown in three sections on the main page, distinguished by whether the user has read, is reading, or will read a given book. The search page provides a section to look up a specific topic (limited to certain queries) and will update results as search items are typed. Books in both the bookshelves page and the search page have associated buttons to add or remove them from bookshelves as well as to toggle between bookshelves. Design The main page is composed of three sections for \"currently reading\", \"want to read\", and \"read\". You can also add many books to a single section. Selections can be modified by clicking on the arrow item for a single book. The search page appears in a similar manner. Type in a search option and see the results that appear. Running The Application To download, you can clone the repository using this terminal command: git clone https://github.com/wbchristerson/reactnd-project-myreads-starter.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder reactnd-project-myreads-starter in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\" To run the application, you will need to have npm installed. See here for installation information. Upon downloading both npm and the project directory, install all project dependencies by running the following command from within the project directory: npm install Afterwards, start the development server with this command: npm start A browser window will open with the main page.","title":"MyReads"},{"location":"MyReads/#my-reads","text":"GitHub repository: https://github.com/wbchristerson/reactnd-project-myreads-starter This application keeps track of a user's book selections from a static database on a server. The user may query certain topics and then select books from the search results to appear on one of three shelves on the main page: \"Currently Reading\", \"Want To Read\", and \"Read\". The project was completed using React, with a basic template and server provided by Udacity. Structure The main page displays the set of books selected. Such books are shown in three sections on the main page, distinguished by whether the user has read, is reading, or will read a given book. The search page provides a section to look up a specific topic (limited to certain queries) and will update results as search items are typed. Books in both the bookshelves page and the search page have associated buttons to add or remove them from bookshelves as well as to toggle between bookshelves. Design The main page is composed of three sections for \"currently reading\", \"want to read\", and \"read\". You can also add many books to a single section. Selections can be modified by clicking on the arrow item for a single book. The search page appears in a similar manner. Type in a search option and see the results that appear. Running The Application To download, you can clone the repository using this terminal command: git clone https://github.com/wbchristerson/reactnd-project-myreads-starter.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder reactnd-project-myreads-starter in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\" To run the application, you will need to have npm installed. See here for installation information. Upon downloading both npm and the project directory, install all project dependencies by running the following command from within the project directory: npm install Afterwards, start the development server with this command: npm start A browser window will open with the main page.","title":"My Reads"},{"location":"NeighborhoodMap/","text":"Neighborhood Map GitHub repository: https://github.com/wbchristerson/neighborhood-map This project includes a neighborhood map of Manhattan Beach, California along with information about several venues there including local restaurants, ocean-related sites, and stores. The project was bootstrapped with Create React App and developed using React . The map feature used in the application was obtained via react-google-maps , an application that integrates React with Google Maps. In turn, that software was itself based on Google Maps API . Documentation about react-google-maps can be found here . In addition, the street views for markers that were used were obtained with the street view feature of Google Maps, also through react-google-maps . Data about the included venues were extracted using the Foursquare API . Structure The focus of this project is on utilizing APIs to develop an application in conjunction with React. Design Users begin with a map of the neighborhood together with a list view of venues. A search feature allows the user to filter this list and upon clicking any item, the user is taken to the chosen venue's item page, detailing information about the location, hours of operation, busy times of the week and day, a photo view, contact information, customer tips, and more. Clicking on the corresponding marker on the map will open a street view of the premises. Markers on the map are filtered in accordance with the filtered query and will animate/bounce when the corresponding item is clicked. Additional features include error handling for failed API requests, responsive design for mobile devices, accessibility features for motor- and visually-impaired users in the form of controlled focus, ARIA roles, and alternate image text, and finally, a service worker to cache the data of visited pages in the event of a poor network connection. Running The Application To download, you can clone the repository using this terminal command: git clone https://github.com/wbchristerson/neighborhood-map.git Alternatively, follow the instructions below to download to a hard drive and to run the application: Navigate to this page. Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder neighborhood-map-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\". To run the application, you will need to have npm installed. See here for installation information. To install all dependencies for the project from the command line, run the following commands in the terminal from within the project directory: cd neighborhood-map npm install You will need a Google Maps Platform API key along with a Foursquare Client ID and a Foursquare Client Secret to use in the application: If you do not have a Google Maps API key already, then you can obtain a Google Maps Platform API key for free here . You will have to create a billing account but there is a built in $200 credit. If you do not have the Foursquare Client ID or Foursquare Client Secret , then you can obtain them here by first creating a free account. After you have all three data items, create a new folder in the src directory called api . Within api , create a Javascript file called APIkey.js . Within this file add the following lines, where YOUR_GOOGLE_KEY , YOUR_FOURSQUARE_CLIENT_ID , and YOUR_FOURSQUARE_CLIENT_SECRET are replaced by your personalized data values (don't forget the delimiting quotes): export const GOOGLE_MAP_API_KEY = 'YOUR_GOOGLE_KEY' export const FOURSQUARE_CLIENT_ID = 'YOUR_FOURSQUARE_CLIENT_ID' export const FOURSQUARE_CLIENT_SECRET = 'YOUR_FOURSQUARE_CLIENT_SECRET' Save the file. Assuming that your location in the terminal is now within the neighborhood-map directory, run the following command to execute the application: npm start (I believe that yarn start will also be sufficient.) Warning: The service worker that is bundled with create-react-app only works in production mode. The page will open in the browser.","title":"Neighborhood Map"},{"location":"NeighborhoodMap/#neighborhood-map","text":"GitHub repository: https://github.com/wbchristerson/neighborhood-map This project includes a neighborhood map of Manhattan Beach, California along with information about several venues there including local restaurants, ocean-related sites, and stores. The project was bootstrapped with Create React App and developed using React . The map feature used in the application was obtained via react-google-maps , an application that integrates React with Google Maps. In turn, that software was itself based on Google Maps API . Documentation about react-google-maps can be found here . In addition, the street views for markers that were used were obtained with the street view feature of Google Maps, also through react-google-maps . Data about the included venues were extracted using the Foursquare API . Structure The focus of this project is on utilizing APIs to develop an application in conjunction with React. Design Users begin with a map of the neighborhood together with a list view of venues. A search feature allows the user to filter this list and upon clicking any item, the user is taken to the chosen venue's item page, detailing information about the location, hours of operation, busy times of the week and day, a photo view, contact information, customer tips, and more. Clicking on the corresponding marker on the map will open a street view of the premises. Markers on the map are filtered in accordance with the filtered query and will animate/bounce when the corresponding item is clicked. Additional features include error handling for failed API requests, responsive design for mobile devices, accessibility features for motor- and visually-impaired users in the form of controlled focus, ARIA roles, and alternate image text, and finally, a service worker to cache the data of visited pages in the event of a poor network connection. Running The Application To download, you can clone the repository using this terminal command: git clone https://github.com/wbchristerson/neighborhood-map.git Alternatively, follow the instructions below to download to a hard drive and to run the application: Navigate to this page. Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder neighborhood-map-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\". To run the application, you will need to have npm installed. See here for installation information. To install all dependencies for the project from the command line, run the following commands in the terminal from within the project directory: cd neighborhood-map npm install You will need a Google Maps Platform API key along with a Foursquare Client ID and a Foursquare Client Secret to use in the application: If you do not have a Google Maps API key already, then you can obtain a Google Maps Platform API key for free here . You will have to create a billing account but there is a built in $200 credit. If you do not have the Foursquare Client ID or Foursquare Client Secret , then you can obtain them here by first creating a free account. After you have all three data items, create a new folder in the src directory called api . Within api , create a Javascript file called APIkey.js . Within this file add the following lines, where YOUR_GOOGLE_KEY , YOUR_FOURSQUARE_CLIENT_ID , and YOUR_FOURSQUARE_CLIENT_SECRET are replaced by your personalized data values (don't forget the delimiting quotes): export const GOOGLE_MAP_API_KEY = 'YOUR_GOOGLE_KEY' export const FOURSQUARE_CLIENT_ID = 'YOUR_FOURSQUARE_CLIENT_ID' export const FOURSQUARE_CLIENT_SECRET = 'YOUR_FOURSQUARE_CLIENT_SECRET' Save the file. Assuming that your location in the terminal is now within the neighborhood-map directory, run the following command to execute the application: npm start (I believe that yarn start will also be sufficient.) Warning: The service worker that is bundled with create-react-app only works in production mode. The page will open in the browser.","title":"Neighborhood Map"},{"location":"PixelArt/","text":"Pixel Art GitHub repository: https://github.com/wbchristerson/pixel-art This project is a one-page application to make colorful pixel images of varying grid sizes. Try the application here . Note: This project is based on a skeleton structure from Udacity. For more information, see the initial commit on the appropriate GitHub page given above. Structure The dimensions of the pixel grid can each be anything from 1 to 50. Once the grid is created, you can choose various colors for the individual pixels. Design The application is a single page which begins with no shown grid and a default color of black. The dimensions of the grid are determined by an input element, which is designed to ensure that you can only enter a number between 1 and 50. By clicking on the color option, a window appears which shows the various colors that can be generated. Color the grid by clicking on individual pixels: Running The Application Run the application in your browser by clicking here . To download, clone the repository using this terminal command: git clone https://github.com/wbchristerson/pixel-art.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button above then choose \"Download ZIP\". Find the folder pixel-art-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\". Open your browser and use Ctrl + O (for Windows machines) to open the file selector on your device. Go to pixel-art-master , enter pixel-art-master again, then select index.html . The game screen will appear.","title":"Pixel Art"},{"location":"PixelArt/#pixel-art","text":"GitHub repository: https://github.com/wbchristerson/pixel-art This project is a one-page application to make colorful pixel images of varying grid sizes. Try the application here . Note: This project is based on a skeleton structure from Udacity. For more information, see the initial commit on the appropriate GitHub page given above. Structure The dimensions of the pixel grid can each be anything from 1 to 50. Once the grid is created, you can choose various colors for the individual pixels. Design The application is a single page which begins with no shown grid and a default color of black. The dimensions of the grid are determined by an input element, which is designed to ensure that you can only enter a number between 1 and 50. By clicking on the color option, a window appears which shows the various colors that can be generated. Color the grid by clicking on individual pixels: Running The Application Run the application in your browser by clicking here . To download, clone the repository using this terminal command: git clone https://github.com/wbchristerson/pixel-art.git Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button above then choose \"Download ZIP\". Find the folder pixel-art-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\". Open your browser and use Ctrl + O (for Windows machines) to open the file selector on your device. Go to pixel-art-master , enter pixel-art-master again, then select index.html . The game screen will appear.","title":"Pixel Art"},{"location":"Readables/","text":"Readables GitHub repository: https://github.com/wbchristerson/reactnd-project-readable-starter This project is a forum (content/comment) application in which users may post content to predefined categories, comment on their posts and other users' posts, and vote on posts and comments. The backend server for storing information was provided by Udacity. I made the rest of the application using create-react-app along with React and Redux. Structure On all pages of the application there is a navigation bar listing the name of the application as well as the different post categories. Clicking on a post category will lead the user to a page listing all posts of that category. The project opens with a main page listing all currently published posts. There are options at the top of the page for the order of presentation of posts, by date of latest modification as well as by net number of votes. There are also options for composing a new post, with a button that opens a modal for such creation. Clicking on any post takes the user to a page for that particular post, listing its data as well as all additional comments. Each post itself has a sample avatar image, a title, and content. Content is only visible on the specific post page (not in the main list view). In addition, there are options to edit a post as well as to delete it. Selecting editing will open a modal similar to the composition modal. On the far left side of each post there are also buttons for increasing and decreasing the vote count for a particular post. Comments have similar display styles. Design A view of a sample main page with posts sorted by latest modification: A view of a sample page for a specific post together with its associated comments: A sample edit modal for a post: Running The Application To download, you can clone the repository using this terminal command: git clone https://github.com/wbchristerson/reactnd-project-readable-starter Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder reactnd-project-readable-starter-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\". To run the application, you will need to have npm installed. See here for installation information. Upon downloading both npm and the project directory, install all dependencies for the API server and execute it from the command line in the project directory by running the following commands in the terminal: cd api-server npm install node server In another terminal window, run the following commands for the front-end from within the project directory: cd frontend npm start A browser window will open with the project's main page.","title":"Readables"},{"location":"Readables/#readables","text":"GitHub repository: https://github.com/wbchristerson/reactnd-project-readable-starter This project is a forum (content/comment) application in which users may post content to predefined categories, comment on their posts and other users' posts, and vote on posts and comments. The backend server for storing information was provided by Udacity. I made the rest of the application using create-react-app along with React and Redux. Structure On all pages of the application there is a navigation bar listing the name of the application as well as the different post categories. Clicking on a post category will lead the user to a page listing all posts of that category. The project opens with a main page listing all currently published posts. There are options at the top of the page for the order of presentation of posts, by date of latest modification as well as by net number of votes. There are also options for composing a new post, with a button that opens a modal for such creation. Clicking on any post takes the user to a page for that particular post, listing its data as well as all additional comments. Each post itself has a sample avatar image, a title, and content. Content is only visible on the specific post page (not in the main list view). In addition, there are options to edit a post as well as to delete it. Selecting editing will open a modal similar to the composition modal. On the far left side of each post there are also buttons for increasing and decreasing the vote count for a particular post. Comments have similar display styles. Design A view of a sample main page with posts sorted by latest modification: A view of a sample page for a specific post together with its associated comments: A sample edit modal for a post: Running The Application To download, you can clone the repository using this terminal command: git clone https://github.com/wbchristerson/reactnd-project-readable-starter Alternatively, follow the instructions below to download to a hard drive: Navigate to this page . Click the green \"Clone or download\" button towards the right then choose \"Download ZIP\". Find the folder reactnd-project-readable-starter-master in your Downloads folder or wherever it was placed on your device. Right click and choose \"Extract All\". To run the application, you will need to have npm installed. See here for installation information. Upon downloading both npm and the project directory, install all dependencies for the API server and execute it from the command line in the project directory by running the following commands in the terminal: cd api-server npm install node server In another terminal window, run the following commands for the front-end from within the project directory: cd frontend npm start A browser window will open with the project's main page.","title":"Readables"}]}